require "open-uri"

class Malware < ActiveRecord::Base
  before_create :delete_previous

  URI_HOST_INDEX = 2
  URI_PATH_INDEX = 5
  URI_QUERY_INDEX = 7
  
  HOSTS_LIMIT = 10 #limit on how many host components (ie subdomains+domain) we'll look at'
  PATHS_LIMIT = 20 #limit on how many path components (separated by '/') we'll look at'

  # Inserting/deleting one entry at a time is painfully slow
  # Inserting in batches of 100 entries reduces time to ~1 minute
  @batch_size = 100
  
  # Fetch changes from google servers and store them in the database
  # Might be a slow operation, specially on the first run
  def self.update
    options = find(:first, :order => "created_at DESC")
    unless options
      options = self.new
      options.black_major ||= 1
      options.black_minor ||= -1
      options.malware_major ||= 1
      options.malware_minor ||= -1
      
      options.save
    end
    
    update_uri = "http://sb.google.com/safebrowsing/update?client=api" +
                 "&apikey=#{SAFEBROWSING_API_KEY}" +
                 "&version=goog-black-hash:#{options.black_major}:#{options.black_minor}," +
                 "goog-malware-hash:#{options.malware_major}:#{options.malware_minor}"

    logger.info("Updating malware info (#{options.black_major}.#{options.black_minor} #{options.malware_major}.#{options.malware_minor})")
    added = 0
    removed = 0
    to_add = []
    to_remove = []
    started = Time.now
    
    # FIXME: try batch inserts if performance becomes an issue
    open(update_uri) do |f|
      f.each_line do |line|
        if (line =~ /\[goog-black-hash (\d+).(\d+)/)
          options.black_major = $1
          options.black_minor = $2
          logger.info("Found new black version (#{options.black_major},#{options.black_minor})")
        elsif (line =~ /\[goog-malware-hash (\d+).(\d+)/)
          options.malware_major = $1
          options.malware_minor = $2
          logger.info("Found new malware version (#{options.malware_major}.#{options.malware_minor})")
        elsif (line =~ /\+([0-9a-f]{32})/)
          to_add << $1
          # MalwareHash.create(:url => $1)
          added += 1
        elsif (line =~ /-([0-9a-f]{32})/)
          to_remove << $1
          # MalwareHash.delete_all(["url = ?", $1])
          removed += 1
        end
        
        if to_add.size > @batch_size
          MalwareHash.add_batch(to_add)
          to_add = []
        end
        
        if to_remove.size > @batch_size
          MalwareHash.delete_batch(to_remove)
          to_remove = []
        end
        
      end
    end

    MalwareHash.add_batch(to_add)
    MalwareHash.delete_batch(to_remove)
    
    options.save
    logger.info("Updated malware info (in #{Time.now - started}s) +#{added}/-#{removed} (#{options.black_major}.#{options.black_minor} #{options.malware_major}.#{options.malware_minor})")
  end
  
  # Check a url against the malware database
  # URLs can be in any form:
  # * http://example.com/foo/bar.html
  # * example.com/foo/
  # * example.com
  def self.check(url)
    #Make sure url is according to http://code.google.com/apis/safebrowsing/developers_guide.html#ListFormat
    #For the hostname, the client will try at most 5 different strings. They are:
    #
    #    the exact hostname in the url
    #    up to 4 hostnames formed by starting with the last 5 components and successively removing the
    #    leading component. The top-level domain can be skipped. These additional hostnames should not
    #    be checked if the host is an IP address.
    #
    #For the path, the client will also try at most 6 different strings. They are:
    #
    #    the exact path of the url, including query parameters
    #    the exact path of the url, without query parameters
    #    the 4 paths formed by starting at the root (/) and successively appending path components,
    #    including a trailing slash.
    is_blacklisted = false
    url="http://"+url unless url =~ /^http/
    url.downcase!
    url << "/" unless url =~ /\/$/ #ensure a trailing slash
    uri = URI.split(url)
    query=uri[URI_QUERY_INDEX]

    #we'll be lazy and test against all components since top level can be separated by one or two periods
    hosts=uri[URI_HOST_INDEX].split(".")
    return false if hosts.count > HOSTS_LIMIT #don't want to get stuck in a loop'
    until hosts.count==0 do
      tmp_host = hosts.join(".")
      if MalwareHash.check(tmp_host+"/") ||
          (query.blank? ? false : MalwareHash.check(tmp_host+"?"+query))
        is_blacklisted=true
        break
      else
        paths = uri[URI_PATH_INDEX].split("/").reject{|p|p.blank?}
        break false if paths.count > PATHS_LIMIT #don't want to get stuck in a loop'
        paths.count.times do |i|
          tmp_path = ([tmp_host]+paths.slice[0,i+1]).join("/")
          if MalwareHash.check(tmp_path+"/") ||
              (query.blank? ? false : MalwareHash.check(tmp_path+"?"+query))
            is_blacklisted=true
            break
          end
        end
      end
      hosts.shift
    end
    is_blacklisted
  end

  def is_blacklisted?(url)
    check(url)
  end

  
private

  def delete_previous
    Malware.delete_all
  end
end
